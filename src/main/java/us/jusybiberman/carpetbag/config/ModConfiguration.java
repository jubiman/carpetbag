package us.jusybiberman.carpetbag.config;

import net.minecraftforge.common.config.Configuration;
import net.minecraftforge.fml.common.FMLLog;
import net.minecraftforge.fml.common.event.FMLPreInitializationEvent;
import org.apache.logging.log4j.Level;
import com.google.common.collect.Sets;
import net.minecraftforge.common.MinecraftForge;
import net.minecraftforge.common.config.Configuration;
import net.minecraftforge.common.config.Property;
import net.minecraftforge.fml.client.event.ConfigChangedEvent;
import net.minecraftforge.fml.common.event.FMLInitializationEvent;
import net.minecraftforge.fml.common.event.FMLPostInitializationEvent;
import net.minecraftforge.fml.common.event.FMLPreInitializationEvent;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;

import us.jusybiberman.carpetbag.Carpetbag;

import java.awt.*;
import java.io.File;
import java.util.HashSet;

public class ModConfiguration {
	private static Configuration mainConfig;
	public static int DIMENSION_PROVIDER_ID = -1;
	public static int DUNGEON_DIMENSION_AMOUNT = 3;
	public static boolean randomizeSeed = false;
	public static boolean tallChunkFriendly = false;
	public static boolean dimensionFolderIsDeletedWithSafeDel = true;

	public static void init(FMLPreInitializationEvent event) {
		mainConfig = new Configuration(new File(event.getModConfigurationDirectory().getAbsolutePath(), Carpetbag.MOD_ID + ".mainConfig"));
		try {
			mainConfig.load();
			mainConfig.addCustomCategoryComment("general", "General settings for all mods using mcjtylib");
			mainConfig.addCustomCategoryComment("Entity IDs", "Set the ID's for the entities to ensure that they don't clash with other mod's ids");
			mainConfig.addCustomCategoryComment("GUI IDs", "Set the ID's for the GUI's to ensure that they don't clash with other mod's ids");
			mainConfig.addCustomCategoryComment("Dimensions", "Settings for dimensions generated by carpetbag");
			mainConfig.addCustomCategoryComment("Biomes", "Set the ID's for the GUI's to ensure that they don't clash with other mod's ids");


			//mainConfig.addCustomCategoryComment(StyleConfig.CATEGORY_STYLE, "Style settings for all mods using mcjtylib");
			//StyleConfig.init(mainConfig);
		} catch (RuntimeException e1) {
			FMLLog.log(Level.ERROR, e1, "Problem loading config file: carpetbag.mainConfig!");
		} finally {
			if (mainConfig.hasChanged()) {
				mainConfig.save();
			}
		}
		
		tallChunkFriendly = mainConfig.get("general", "tallChunkFriendly", tallChunkFriendly,
				"If true then mods using McJtyLib might try to be as friendly as possible to mods that support very tall chunks (taller then 256). No guarantees however! Set to false for more optimal performance").getBoolean();
		dimensionFolderIsDeletedWithSafeDel = mainConfig.get("general", "dimensionFolderIsDeletedWithSafeDel", dimensionFolderIsDeletedWithSafeDel,
				"If this is enabled the /deletedungeon <id> command will also delete the DIM<id> folder. If false then this has to be done manually").getBoolean();


		DIMENSION_PROVIDER_ID = mainConfig.get("Dimensions", "DIMENSION_PROVIDER_ID", DIMENSION_PROVIDER_ID, "Set the base ID for the Dungeon Dimensions. Multiple dimensions will be created with incrementing IDs. (-1 means try to find one automatically)").getInt();
		DUNGEON_DIMENSION_AMOUNT = mainConfig.getInt("DIMENSION_PROVIDER_ID", "Dimensions", DIMENSION_PROVIDER_ID, 1, 999, "Set the amount of Dungeon Dimensions to create.");
		randomizeSeed = mainConfig.get("Dimensions", "randomizeSeed", randomizeSeed, "Set the amount of Dungeon Dimensions to create.").getBoolean();
	}

	public static Configuration getMainConfig() {
		return mainConfig;
	}

	private static boolean needsRestart = true;

	public static int loadPropInt(String propName, String category, String desc, int default_, int min, int max) {
		Property prop = mainConfig.get(category, propName, default_, desc, min, max);
		prop.setComment(desc);
		setNeedsRestart(prop);

		return prop.getInt(default_);
	}

	public static int loadPropInt(String propName, String category, String desc, int default_) {
		Property prop = mainConfig.get(category, propName, default_);
		prop.setComment(desc);
		setNeedsRestart(prop);

		return prop.getInt(default_);
	}

	public static double loadPropDouble(String propName, String category, String desc, double default_) {
		Property prop = mainConfig.get(category, propName, default_);
		prop.setComment(desc);
		setNeedsRestart(prop);

		return prop.getDouble(default_);
	}

	public static double loadPropDouble(String propName, String category, String desc, double default_, double min, double max) {
		Property prop = mainConfig.get(category, propName, default_, desc, min, max);
		prop.setComment(desc);
		setNeedsRestart(prop);

		return prop.getDouble(default_);
	}

	public static boolean loadPropBool(String propName, String category, String desc, boolean default_) {
		Property prop = mainConfig.get(category, propName, default_);
		prop.setComment(desc);
		setNeedsRestart(prop);

		return prop.getBoolean(default_);
	}

	public static String loadPropString(String propName, String category, String desc, String default_) {
		Property prop = mainConfig.get(category, propName, default_);
		prop.setComment(desc);
		setNeedsRestart(prop);
		return prop.getString();
	}

	public static String[] loadPropStringList(String propName, String category, String desc, String[] default_) {
		Property prop = mainConfig.get(category, propName, default_);
		prop.setComment(desc);
		setNeedsRestart(prop);
		return prop.getStringList();
	}

	public static HashSet<String> loadPropStringSet(String propName, String category, String desc, String[] default_) {
		Property prop = mainConfig.get(category, propName, default_);
		prop.setComment(desc);
		setNeedsRestart(prop);
		return Sets.newHashSet(prop.getStringList());
	}

	public static Color loadPropColor(String propName, String category, String desc, Color default_) {
		Property prop = mainConfig.get(category, propName, colorToString(default_));
		prop.setComment(desc);
		setNeedsRestart(prop);
		return stringToColor(prop.getString());
	}

	private static String colorToString(Color color) {
		return String.format("%s,%s,%s,%s", color.getRed(), color.getGreen(), color.getBlue(), color.getAlpha());
	}

	private static Color stringToColor(String string) {
		String[] values = string.split(",");
		return new Color(
				Integer.parseInt(values[0]),
				Integer.parseInt(values[1]),
				Integer.parseInt(values[2]),
				Integer.parseInt(values[3])
		);
	}


	public static GreyList<String> loadGreyList(String propName, String category, String desc, GreyList<String> default_){
		boolean isWhiteList = loadPropBool(propName+"IsWhitelist", category,"Whether "+propName+" should be a whitelist or a blacklist", default_.isWhiteList);
		String[] values = loadPropStringList(propName, category, desc, default_.defaults);

		default_.setWhiteList(isWhiteList);
		default_.setup(values);

		return default_;
	}

	public static void doesNotNeedRestart(Runnable op)
	{
		needsRestart = false;
		op.run();
		needsRestart = true;
	}

	private static void setNeedsRestart(Property prop) {
		if (needsRestart)
			prop.setRequiresMcRestart(true);
	}
}
